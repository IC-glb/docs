>此次学习主要以基于ARM的微机原理与接口技术：STM32嵌入式系统架构、编程与应用

## 第六章：通用输入/输出接口
>从本章开始介绍STM32F103VET6微控制器的典型外设。本章介绍STM32F103VET6微控制器的通用输入/输出接口(General-Purpose Input/Output,**GPIO**)的工作模式、结构及使用方法。

### GPIO端口的模式
* **输入浮空**：引脚既不接高电平也不接低电平。*不建议悬空，易受干扰*

* **输入上拉**：上拉就是将不确定的信号通过一个电阻拉到高电平Vcc。同时电阻起到限流作用。

* **输入下拉**：把电压拉低至GND。

* **模拟输入**：模拟输入就是传统方式的模拟量输入。数字输入就是输入数字信号，0/1

* **开漏输出**：输出端相当于三极管的集电极，要达到高电平状态需要上拉电阻才行。

* **推挽式输出**：可以输出高低电平，连接数字器件。一般指两个三极管分别收到两个互补信号的控制，总是在一个三极管导通的时候另一个截至

* **推挽式复用功能**

* **开漏复用功能**

!>*对于复用的输入功能，端口必须配置成输入模式(浮空、上拉或下拉)且输入引脚必须由外部 驱动。对于复用输出功能，端口必须配置成复用功能输出模式(推挽或开漏)。对于双向复用功能，端口位必须配置复用功能输出模式(推挽或开漏)。这时，输入驱动器被 配置成浮空输入模式*

---

## 中断控制器
> 中断指CPU立马停下手头的工作，去做指定工作的过程。而这个工作叫《中断服务程序》，其有指定的入口地址（中断向量）。而中断向量一般存放在一块区域，专门用于存放中断向量，**中断向量表**。而存储中断向量的地址，称为**中断向量地址**


### NVIC中断控制器

#### 嵌套向量中断控制器
1. 负责中断管理控制，提供可嵌套、动态优先级的中断管理。
2. 嵌套向量控制器特征：支持中断优先级的动态调整，使用抢占优先级和从优先级管理中断。外部IO中断管脚可以配置。

#### 抢占优先级和响应优先级
1. 抢占优先级：高抢占优先级的中断会打断当前用户程序或者**正在执行的低抢占优先级的中断服务程序--中断嵌套**

2. 在抢占优先级相同的情况下，如果有低从优先级的中断服务程序正在执行，则高从优先级的中断不能打断，即不能嵌套中断。

3. 响应优先级(sub):当抢占优先级相同时，响应优先级高的先执行，但是不能相互打断；
#### **抢占优先级和从优先级**
1. Cortex M3处理器中定义了8个位来设置中断源的优先级、Stm32L152实际只使用了其中4个位。
2. 分别有0-4 共5组中断优先级方式。
3. 每个分组都有不同的抢占优先级与从优先级
4. 数值越小，表示优先级越高；


#### NVIC寄存器
|名称|为数|个数|作用|
|----|---|----|-----|
|中断使能寄存器（ISER）|32|8|每一位控制一个中断（打开）|
|中断失能寄存器（ICER）|32|8|每一位控制一个中断（关闭）|
|应用程序中断及复位控制寄存器（AIRCR）|32|1|位[10:8]控制中断优先级分组|
|中断优先级寄存器IPR|8|240|8个位对应一个中断，而STM32只使用高4位|

>1、ISER与ICER寄存器共有32*8=356,用于控制240个中断的打开与关闭；

>2、AIRCR寄存器，位10、9、8三位用于控制优先级的分组，三位共2*2*2=8种，取其中的5组作为中断优先级的分组情况；

>3、IPR寄存器，用于控制中断的优先级，包括抢占优先级与响应优先级，高4位控制，至于哪几位控制抢占，哪几位控制响应，由AIRCR寄存器说了算；
### NVIC控制器库函数

主要的函数

|函数名|描述|
|------|------|
|NVIC_PriorityGroupConfig |设置优先级分组，先占优先级和从优先级|
|NVIC_Init|根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存|
|NVIC_SetVectorTable|设置向量表的位置和偏移|
|NVIC_SystemLPConfig|选择系统进入低功耗模式的条件|


**NVIC_PriorityGroupConfig函数**
```c
// 函数功能：用于设置嵌套向量中断控制器的优先级分组。
// 函数原型：void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup)
// 输入参数： NVIC_PriorityGroup_x x=0~4。
// 如果不执行该函数，默认的分组方式是分组0，抢占优先级为0，可以设置从优先级为0~15 共16种情况

NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2 );

```

**NVIC_Init函数**
```c
typedef struct
{
 uint8_t NVIC_IRQChannel; //设置中断通道
 uint8_t NVIC_IRQChannelPreemptionPriority;//设置响应优先级
 uint8_t NVIC_IRQChannelSubPriority; //设置抢占优先级
 FunctionalState NVIC_IRQChannelCmd; //使能/使能
} NVIC_InitTypeDef;


NVIC_InitTypeDef NVIC_InitStructure;
NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;//串口1中断
NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1 ;// 抢占优先级为1
NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;// 子优先级位2
NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;//IRQ通道使能
NVIC_Init(&NVIC_InitStructure); //根据上面指定的参数初始化NVIC寄存器

```

---

### EXTI外部中断控制器

>外部中断是由处理器的IO管脚产生中断，而EXTI专门处理这些外部中断
外部中断/事件控制器EXTI由23个产生中断/事件请求的边沿检测器组成，其中16用于IO中断，7个用于特殊事件处理。


- 每个输入线可以独立地配置输入类型（电平、脉冲），以及对应的触发事件（上升沿、下降沿或双边沿触发）。
- 每个输入线都可以独立地被触发和屏蔽。
- 每个中断线都有专用的状态位；

 
其中按照控制功能划分，共分为4个部分；有两条主线，一条是由输入线到 NVIC 中断控制器（123），一条是由输入线到脉冲发生器（124）。

输入线：是线路的信息输入端，它可以通过配置寄存器设置为任何一个 GPIO 口，或者是一些外设的事件。输入线一般都是存在电平变化的信号。

1、边沿检测电路：上升沿触发选择寄存器和下降沿触发选择寄存器。边沿检测电路以输入线作为信号输入端，如果检测到有边沿跳变就输出有效信号‘1’，就输出有效信号‘1’到标号2部分电路，否则输入无效信号‘0’。边沿跳变的标准在于对两个触发选择寄存器的设置。

2、或门电路：它的两个信号输入端分别是软件中断事件寄存器和边沿检测电路的输入信号。或门电路只要输入端有信号‘1’，就会输出‘1’，所以就会输出 ‘1’到标号3电路和标号4电路。

3、与门电路(标号3):两个信号输入端分别是中断屏蔽寄存器和标号2电路信号。如果中断屏蔽寄存器设置为 0 时，不管从标号2电路输出的信号特性如何，最终标号3电路输出的信号都是 0；假如中断屏蔽寄存器设置为 1 时，最终标号3电路输出的信号才由标号2电路输出信号决定，这样子就可以简单控制 中断屏蔽寄存器 来实现中断的目的。标号4电路输出 ‘1’就会把请求挂起寄存器(EXTI_PR)对应位置 1。

4、与门电路(标号4)：输入端来自标号2电路以及来自于事件屏蔽寄存器。可以简单的控制事件屏蔽寄存器来实现是否产生事件的目的。标号4电路输出有效信号 1 就会使脉冲发生器电路产生一个脉冲，而无效信号就不会使其产生脉冲信号。脉冲信号产生可以给其他外设电路使用，例如定时器，模拟数字转换器等，这样的脉冲信号一般用来触发 TIM 或者 ADC 开始转换。产生中断线路目的使把输入信号输入到 NVIC，进一步运行中断服务函数，实现功能。

---
**EXIT相关寄存器**

在上述工作原理图中，所涉及的寄存器共有7个，但是对于外部中断来说，我们只需要掌握其中四个寄存器：上升沿触发选择寄存器(EXTI_RTSR)、下降沿触发选择寄存器(EXTI_FTSR)、挂起寄存器(EXTI_PR)与中断屏蔽寄存器(EXTI_IMR)。

 


### EXTI外部中断控制器库函数

### 中断使用示例

① 初始化IO口为输入。
 GPIO_Init();

② 开启IO口复用时钟。
RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);

③ 设置IO口与中断线的映射关系。
void GPIO_EXTILineConfig();

④ 初始化线上中断，设置触发条件等。
EXTI_Init();

⑤ 配置中断分组（NVIC），并使能中断。
NVIC_Init();

⑥ 编写中断服务函数。
EXTIx_IRQHandler();

⑦ 清除中断标志位
 EXTI_ClearITPendingBit();