<center><h2>C++学习</h2></center>

>巩固与学习C++ ，只会记录不懂的、不熟悉和没见过的知识

## 🎉 目录

1. [**第一章C++概述**](#C++概述)
    1. [枚举enum](#枚举enum)
    2. [函数重载](#函数重载)
    3. [面向对象的三大特性](#面向对象的三大特性)

---
## C++概述

### 枚举enum

```c++
enum Direction{North , South ,East ,West}
```

当C++编译器遇到该类型定义时，它会按常量名的顺序，从0开始给每个常量赋值。因此NORTH 被赋值为0，EAST被赋值为1，SOUTH被赋值为2，WEST被赋值为3。C++允许你给每个枚举类型的常量显示地赋值。例如，以下类型声明:

```c++
enum Coin
{
PENNY =1 ,
NICKEL =5 ,
DIME =10,
QUARTER=25,
HALF_DOLLAR=50,
DOLLAR =100
};
```

引人了一个表达美国货币的枚举类型，其中每一个常量定义了相应硬币的货币价值。如果你给枚举类型中的一些而非全部常量提供了初值，那么C++编译器会自动地给未赋值的常量赋以一个你所提供的最后一个常量值的后继整数值。

<details>
<summary>示例</summary>

```C++
#include <iostream>

enum Day {
    Sunday,     // 默认值为 0
    Monday,     // 默认值为 1
    Tuesday,    // 默认值为 2
    Wednesday,  // 默认值为 3
    Thursday,   // 默认值为 4
    Friday,     // 默认值为 5
    Saturday    // 默认值为 6
};

int main() {
    Day today = Wednesday;  // 将枚举变量赋值为 Wednesday
    std::cout << "Today is day number: " << today << std::endl;  // 输出 3
    return 0;
}

```
</details>


### 函数重载

在C++中，函数名相同但函数的参数列表不同是合法的。当编译器遇到调用函数的函数名指代不唯一的情况时，编译器会检查调用函数时所传实参并选择最适合的函数版本。

```c++
int abs(int x)
{

}

int abs(float x){

}
```

### 面向对象的三大特性

`封装` `继承` `多态`

- `封装`:将对象的属性和方法绑定在一起，形成一个独立、封闭的单元。外部只能通过对象提供的API接口访问/操作对象的内部状态。而无法直接访问或者修改对象的数据。

- `继承`:一个类可以从另一个类继承某些属性和方法，在基础上添加新的属性和方法

- `多态`:同一个消息可以被不同对象解释执行，做出不同的响应。一般通过虚函数和模板等机制实现。

### 引用
`&a = b`
改变a也会改变b
操作类似于指针，但是引用不能被赋值为NULL，也不能进行指针运算。

**C/C++引用和指针的区别？**

指针是一个实体，需要`分配内存空间`；引用只是变量的别名，`不需要分配内存空间`。引用在定义的时候`必须进行初始化`，并且`不能够改变`；指针在定义的时候`不一定要初始化`，并且`指向的空间可变`。

### 内联函数和普通函数

>当调用一个普通函数时，程序控制会跳转到函数的地址执行代码，执行完后返回调用点。这个跳转过程有一定的开销

内联函数的主要目的是为了`减少函数调用时的开销`。
通过使用` inline 关键字`，建议编译器将函数的代码直接插入到调用点，而不是进行传统的函数调用跳转。
这样做可以`减少函数调用的开销`，尤其是对`非常小的、频繁调用的函数`。


**内联函数的特点：**
- 通过减少函数调用的开销提升性能，尤其是对小型函数。
- 编译器可能会拒绝内联过于复杂或较大的函数。
- 适用于短小、简单的函数，如访问器、数学计算等。

**内联函数的使用注意事项**
- `代码膨胀`:如果多个内联函数被多个地方调用，编译器会在每个调用点插入函数的代码，导致生成的可执行文件体积增大。
- `递归函数`:递归函数通常不适合内联，因为递归调用可能导致无限循环的内联展开。
- `复杂函数`:过于复杂的函数不适合内联，编译器可能会自动忽略 inline。


### 常量指针和指针常量

#### 常量指针
在`C`语言中，常量指针的定义方式为`const int* ptr`，表示指向int类型的常量指针，例如
```c++
int main() {
    int a = 20;
    int b = 10;
    int const *ptr ;
    ptr = &b;
    cout<<ptr<<"  "<<&ptr<<"  "<<*ptr<<endl;    //0x62fe1c  0x62fe10  10

    ptr = &a;
    cout<<ptr<<"  "<<&ptr<<"  "<<*ptr<<endl;    //0x62fe1c  0x62fe10  20

    return 0;
}
```
- ptr：指针 ptr 的值，也就是 b 的地址。
- &ptr：指针 ptr 本身的地址。
- *ptr：指针 ptr 指向的值，也就是 b 的值（这里为 10）。

#### 指针常量
而指针常量的定义方式为`int* const ptr`，表示指向int类型的指针常量，指针所指向的地址可以改变，但是不能通过指针修改地址对应的值。


### 野指针

>野指针是指指向已经`被释放`或者`无效的内存空间的指针`，这是 C++ 中常见的一个程序错误。当我们访问野指针时，程序会出现不可预期的行为，甚至崩溃。

**避免野指针，我们可以采取以下措施:**

-  指针使用前初始化
```C++
int* p = nullptr; // 初始化为空指针
```

- 指针使用后及时置空

当指针变量不再使用时，我们应该将其置为空指针，防止误用。这样可以有效地避免产生野指针。
```c++
int* p = new int;
*p = 10;
delete p;
p = nullptr;  // 置空指针，避免野指针产生
```

- 不要重复释放已经释放的内存

在释放指针所指向的内存空间之后，我们应该将该指针赋值为 `NULL` 或 `nullptr`，以防止该指针被误用。

```c++
int* p = new int;
delete p;
p = nullptr;  // 置空指针，避免野指针产生// 以下代码会产生错误，因为指针 p 已经被释放delete
```

- 避免使用悬空指针

当一个指针变量超出了其所在作用域或者被删除时，它就成为了“悬空指针”，这是一种常见的野指针。


### C++多态

假设你是一位公司经理，你手下有不同类型的员工，例如“程序员”和“设计师”。你告诉他们去“工作”，但每个员工的工作内容其实不一样。程序员写代码，而设计师画图。

多态就是这样一种能力：虽然你发出的命令是一样的——让他们“工作”，但根据员工的具体类型，他们的工作方式是不同的。程序员做程序员的事，设计师做设计师的事。这就是多态：`相同的指令，表现出不同的行为`。


在 C++ 中，父类（比如“员工”）提供了一个虚函数 work()，子类（比如“程序员”和“设计师”）分别重写了这个函数，具体执行不同的工作内容。当你使用一个指向父类的指针或者引用时，程序会根据实际的子类类型来决定调用哪个 work() 函数。

<details>

```c++

#include <iostream>
using namespace std;

class Employee {
public:
    // 虚函数，父类定义了“工作”这个动作
    virtual void work() {
        cout << "Employee is working." << endl;
    }
};

class Programmer : public Employee {
public:
    // 子类“程序员”重写了“工作”函数
    void work() override {
        cout << "Programmer is coding." << endl;
    }
};

class Designer : public Employee {
public:
    // 子类“设计师”重写了“工作”函数
    void work() override {
        cout << "Designer is drawing." << endl;
    }
};

int main() {
    Employee* e1 = new Programmer();  // 使用父类指针指向程序员对象
    Employee* e2 = new Designer();    // 使用父类指针指向设计师对象

    e1->work();  // 调用的是程序员的 work()，输出：Programmer is coding.
    e2->work();  // 调用的是设计师的 work()，输出：Designer is drawing.

    delete e1;
    delete e2;

    return 0;
}

```
</details>

## 多态实现




## 虚函数



## 数组